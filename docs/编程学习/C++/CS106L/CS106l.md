# CS106L

## Introduction

- 通用编程语言
- 编译型语言
- 多范式语言
- 中级语言

## A Better C

## Stream

#### fstream

文件读取示例：

```c++
ifstream myStream("myFile.txt"); //声明类型

ifstream myStream1; //或者
myStream1.open("myFile.txt");

int myInteger;
myStream >> myInteger; //读取
```

`.is_open()`用来检查文件被正常打开  
文件写入：

```c++
ofstream myStream("myFile.txt");

```

:::tip tip
当用字符串储存文件名时，要将 string 转换成 C-style string
`ifstream input(myString.c_str());`
:::

#### manipulator

- `setw`(set width)用来控制`cout`输出的宽度,头文件`<iomanip>`
  > 要输出的字数小于 width 时，前面补空白，大于时完整输出

```c++
cout << setw(10) << 111 << endl;
```

还可以控制是左空白还是右空白：

```c++
cout << '[' << left << setw(10) << "Hello!" << ']' << endl;
cout << '[' << right << setw(10) << "Hello!" << ']' << endl;
```

输出：

```txt
[          Hello!]
[Hello!          ]
```

- `setfill`和 setw 配合使用，输出大量指定字符

```c++
cout << setfill('0') << setw(8) << 1000 << endl; // 00001000
cout << setw(8) << 1000 << endl; //00001000
```

- `boolalpha` 用于将 01 转换成`true`or`false`输出(`noboolalpha`相反)

```c++
cout << true << endl; // 1
cout << boolalpha << true << endl; // true
```

- `hex`、`dec`、`oct` 进制相关（十六进制、十进制、八进制）

```c++
cout << 10 << endl; // Output: 10
cout << dec << 10 << endl; // Output: 10
cout << oct << 10 << endl; // Output: 12
cout << hex << 10 << endl; // Output: a
cin >> hex >> x; // Reads a hexadecimal value.
```

- `ws`跳过空白字符

#### 判断输入失败

`input.fail()` (`input`是`ifstream`类型)  
两种方法：

```c++
while(true)
{
	if(input.fail()) break;
	...
}
```

```c++
while(input >> myValue)
{
	...
}
```

#### stirngstream

头文件`<sstream>`  
`stringstream`用临时字符串缓存区读写数据  
可以解决混合类型输入输出问题  
可以将混合类型分开储存

```c++
int levelNum = /* ... */;
stringstream messageText;
messageText << "Level " << levelNum << " is out of bounds.";
MessageBoxAlert(messageText.str());
```

```c++
stringstream myConverter;
int myInt;
string myString;
double myDouble;
myConverter << "137 Hello 2.71828";// Insert string data
myConverter >> myInt >> myString >> myDouble; // Extract mixed data
```

和进制转化配合使用：

```c++
stringstream st;
int num = 15;
st << hex << num;//将数字转化成十六进制字符串
st >> hex >> num;//将st作为十六进制输入，num == 15;
st >> num; //默认也是作为十六进制，num == 15;
st >> dec >> num; //发生错误，num == 0;
string s = st.str();// s = "f"
```

#### getline

读取整行  
`getline(stream, stirng, '\n')`

#### 拓展

##### Random Access

自由移动读取位置

- `seekp`和`seekg`  
  可以将 “p” 理解为 “put”，将 “g” 理解为 “get”

```c++
ios::beg	//从文件头开始计算偏移量
ios::end	//从文件末尾开始计算偏移量
ios::cur	//从当前位置开始计算偏移量
```

```c++
file.seekp(32L, ios::beg);//将写入位置设置为从文件开头开始的第 33 个字节（字节 32)
file.seekp(-10L, ios::end);//将写入位置设置为从文件末尾开始的第 11 个字节（字节 10)
file.seekp(120L, ios::cur);//将写入位置设置为从当前位置开始的第 121 个字节（字节 120)
file.seekg(2L, ios::beg);//将读取位置设置为从文件开头开始的第 3 个字节（字节 2)
file.seekg(-100L, ios::end);//读取位置设置为从文件末尾开始的第 101 个字节（字节 100)
file.seekg(40L, ios::cur);//将读取位置设置为从当前位置开始的第 41 个字节（字节 40)
file.seekg(0L, ios:rend);//将读取位置设置为文件末尾
```

- `tellp`和`tellg`  
  都是返回当前位置

## Multi-File Programs, Abstraction, and the Preprocessor(多文件处理、抽象和预处理器)

#### C++编译过程

- preprocessing 拼接插入代码，比如头文件
- compilation 代码被转换成目标代码，检查语法错误
- linking 代码片段被链接在一起，检查函数原型和实现错误

#### 代码模块化、抽象化

优点：

- 简单化（易读）
- 可拓展性
- 复用性

#### include guard

在头文件开头结尾设置，防止重复导入

```c++
#ifndef File_Included
#define File_Included

#endif
```

#### 多文件运行

一个函数会被分在两个文件  
`FileName.h`头文件定义函数原型，同名`FileName.cpp`c++文件实现  
在`vscode`中想要多文件运行：  
用`g++`命令

```sh
g++ -g ./main.cp ./swap.cpp -o main
```

`main`是生成可执行文件的名字  
然后直接在终端执行：

```sh
./main
```

#### 预处理指令

例如：`#include`、`#define`

- 必须独占一行
- 必须在行首

##### `#define`

```c++
#define phrases replacement
```

替换代码中所有`phrases`为`replacement`  
:::tip 提示
只是单纯的替换，不会考虑运算优先级，当要替换为表达式时，最好加上括号
因为`#define`容易出错，最好使用`const`
:::
两者间的分隔为第一个空格  
`replacement`为从空格到换行符之前（所以为空也合法）

##### `#if`

```c++
#if statement
...
#elif another-statement
...
#elif yet-another-statement
...
#else
...
#endif
```

只能使用`#define`的常量、整数、算数和逻辑表达式  
可以用来注释（可嵌套）  
`#if defined()`的返回值：  
如果被定义过返回 true  
没有没定义过返回 false

##### `#ifdef`

相当于`#if defined`
如果被定义过返回 true

##### `#ifndef`

相当于`if not defined`  
如果被定义过返回 false

##### `#undef`

取消定义

##### `#error`

当预处理器读到这个时，会在编译时出错，并显示错误信息  
`#error message`

#### Macros 宏

语法格式：

```c++
#define macroname(parameter1, parameter2, ... , parameterN) macro-body
```

eg:

```c++
#define Max(a, b) ((a) > (b) ? (a) : (b))
```

:::tip 提示
能用 c++代码实现的就少用宏定义，容易出错
:::

#### Inline Functions(内联函数)

```c++
inline int max(int one, int two)
{
	return one > two ? one : two;
}
```

比宏定义安全  
只是建议，交由编译器处理

#### 预处理器的一些技巧

##### 特殊值

`__DATE__`当前日期  
`__TIME__`当前时间  
`__LINE__`当前行  
`__FILE__`当前文件名

##### 字符串类型操作

用带`#`能保留原参数的字符串  
eg:

```c++
#define PRINTOUT(n) cout << #n << " has value " << (n) << endl

int x = 137;
PRINTOUT(x * 42);
```

将会被转换为：

```c++
int x = 137;
cout << "x * 42" << " has value " << (x * 42) << endl;
```

用带`##`可以将两个参数连接在一起,(字符粘贴)  
eg：生成包含输入参数的变量

```c++
#define DECLARE_MY_VAR(type) type my_##type

DECLARE_MY_VAR(int);
```

转换为：

```c++
int my_int;
```

#### X Macro trick

将需要的数据放在`.h`文件里格式为`macroname(arguments)`  
格式：

```c++
#define macroname(arguments) //定义使用参数的方法
#define "filename.h" //导入参数
#undef macroname //取消定义,避免后面发生冲突
```

优点：  
代码更简短  
改动更方便（只需要更改`.h`文件中的数据）

## STL Sequence Containers

标准模板库可以被分为六个部分：

- 容器
- 迭代器
- 算法
- 适配器
- functors
- 分配器

### vector

`v.push_back(num)`向 vector 尾部添加一个新元素 num  
`v.pop_back()`将尾部元素删除  
`v.insert(v.begin()+position, num)`在位置 position 插入一个元素 num  
`v.erase(v.begin()+position)`删除 position 位置的元素  
`v.resize(size, num)`更改元素数量，如果 size 大于原本数量，则多出的被填充为 num  
`v.clear()`清除 vector 中的所有元素  
`v.end()`  
`v.begin()`  
`v.back()`  
`v.front()`

### deque 双端队列

除支持所有`vector`操作外  
`push_front`  
`pop_front`

### 实例：贪吃蛇

[具体代码实现](贪吃蛇实例.md)  
效果：  
![](../../../public/snake.gif)

### busy loop 忙等待循环

可以用来实现程序等待一段时间再执行

头文件`<ctime>`  
`clock()`函数返回程序开始以来经过的时钟滴答数

> 时钟滴答持续时间因系统而异，C++提供了`CLOCKS_PER_SEC`常量将其转化为秒

### rand 随机数

头文件`<cstdlib>`  
_rand()_ 返回一个介于`0`-`RAND_MAX`的整数(RAND*MAX 通常为`32767`)  
\_srand()* 为`rand()`设定种子值，否则生成的随机数序列是相同的  
eg:

```c++
srand(static_cast<unsigned int>(time(NULL)));

double random_number = rand() / (RAND_MAX + 1.0); //返回[0, 1)的小数
```

### more to explore

- stack & queue
- valarray

## STL Associative Containers and Iterators

### `set`集合

表示一个不允许重复元素的未排序元素集合  
:::tip tip
只能存储可以比较大小的类型，不能存储自定义结构体
:::
`set`函数：

| 函数声明                                                                      | 示例                                          | 功能                                                                                                                                     |
| ----------------------------------------------------------------------------- | --------------------------------------------- | ---------------------------------------------------------------------------------------------------------------------------------------- |
| `Constructor: set<T>()`                                                       | `set<int> mySet;`                             | 构建一个空集合                                                                                                                           |
| `Constructor: set<T>(const set<T>& other)`                                    | `set<int> myOtherSet = mySet;`                | 构建一个与另一个集合相同的集合                                                                                                           |
| `Constructor: set<T>(InputIterator start, InputIterator stop)`                | `set<int> mySet(myVec.begin(), myVec.end());` | 构建一个包含指定范围`[start, stop)` 中元素副本的集合。任何重复的元素都会被丢弃，并且元素会被排序。并且，此函数接受来自任何来源的迭代器。 |
| `size_type size() const`                                                      | `int numEntries = mySet.size();`              | 返回集合中包含的元素数量                                                                                                                 |
| `bool empty() const`                                                          | `if(mySet.empty()) { ... }`                   | 返回集合是否为空                                                                                                                         |
| `void clear()`                                                                | `mySet.clear();`                              | 清空集合                                                                                                                                 |
| `iterator begin() const_iterator begin() const`                               | `set<int>::iterator itr = mySet.begin();`     | 返回集合开头的迭代器                                                                                                                     |
| `iterator end()<br>const_iterator end()`                                      | `while(itr != mySet.end()) { ... }`           | 返回集合最后一个元素之后的迭代器                                                                                                         |
| `pair<iterator, bool> insert(const T& value)`                                 | `mySet.insert(4);`                            | 插入指定的值，返回元素迭代器和`bool`的元组(表示元素是否成功插入，为`true`, 或已存在`false`)                                              |
| `void insert(InputIterator begin,InputIterator end)`                          | `mySet.insert(myVec.begin(), myVec.end());`   | 将指定的元素范围插入到集合中，忽略重复项                                                                                                 |
| `iterator find(const T& element) const_iterator find(const T& element) const` | `if(mySet.find(0) != mySet.end()) { ... }`    | 返回指定元素（如果存在）的迭代器，否则返回结束                                                                                           |
| `size_type count(const T& item) const`                                        | `if(mySet.count(0)) { ... }`                  | 如果指定的元素包含在集合中,返回 1，否则返回 0                                                                                            |
| `size_type erase(const T& element)`                                           | `if(mySet.erase(0)) {...} `                   | 删除集合中的元素。在第一种版本中，如果找到指定元素，则将其删<br>除，如果元素在集合中，则函数返回 1，否则返回 0。                         |
| `void erase(iterator itr);`                                                   | `mySet.erase(mySet.begin());`                 | 第二种版本删除由<br>itr 指向的元素                                                                                                       |
| `void erase(iterator start, iterator stop);`                                  | `mySet.erase(mySet.begin(), mySet.end());`    | 最终版本删除范围`[start, stop)`内的元素                                                                                                  |
| `iterator lower_bound(const T& value)`                                        | `itr = mySet.lower_bound(5);`                 | 返回一个迭代器，指向第一个大于或等于指定值的元素                                                                                         |
| `iterator upper_bound(const T& value)`                                        | `itr = mySet.upper_bound(100);`               | 返回一个迭代器，指向第一个大于指定值的元素                                                                                               |

### Iterator 迭代器

_begin()_ 函数返回第一个元素的迭代器  
_end()_ 函数返回指向容器末尾的下一个元素的迭代器  
数据范围为`[begin, end)`  
eg:遍历一个 vector

```c++
for(vector<int>::iterator itr = myVector.begin();
itr != myVector.end(); ++itr)
	cout << *itr << endl;
```

#### 二分查找函数

_lower_bound()_ 接受一个值，返回容器中第一个大于等于该值的元素的迭代器  
_upper_bound()_ 接受一个值，返回容器中第一个大于该值的元素的迭代器

### pair

`pair`是一个简单的容器类型,它可以存储两个不同类型的元素  
头文件`<utility>`  
声明 `pair<TypeOne, TypeTwo>`  
eg:

```c++
pair<int, string> myPair;
myPair.first = 37;
myPair.second = "C++ is awesome!";
```

`make_pair()`函数：可以在定义的同时初始化

```c++
pair<int, string> muPair = make_pair(137, "string!");
```

### map

用来表示映射关系  
map 中的数据被存在键值对中  
在幕后，map 使用平衡二叉树实现，因此和`set`类似，`map`中的键必须可以通过小于号比较，但值不需要，可以用自定义结构体  
eg:创建并赋值

```c++
map<string, int> numberMap;

//使用[]会隐式创建键值对，如果不赋值默认赋0
numberMap["zero"] = 0;
numberMap["one"] = 1;
numberMap["two"] = 2;

//显式创建
numberMap.insert(make_pair("zero", 0));
```

:::tip tip
这两种方式在键已存在时有区别
第一种直接赋值会覆盖为最新的值
第二种插入会失败，保留原有的值并返回`pair<iterator, false>`
:::

如果想在查找键值对时，不意外创建新的键值对，可以使用 _find()_ 函数  
`map`的元素解引用后是键值对

```c++
map<string, int>::iterator itr = numberMap.find("xyzzy");
if(itr == numberMap.end())
	cout << "Key does not exist." << endl;
else
	cout << "Key " << itr->first << " has value " << itr->second << endl;
```

删除：  
_myMap.erase("key")_

`map`函数

| 声明                                                                                                     | 示例                                                                                             | 功能                                                                                                                                                              |
| -------------------------------------------------------------------------------------------------------- | ------------------------------------------------------------------------------------------------ | ----------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| `Constructor: map<K, V>()`                                                                               | `map<int, string> myMap;`                                                                        | 构建一个空映射                                                                                                                                                    |
| `Constructor: map<K, V>(const map<K, V>& other)`                                                         | `map<int, string> myOtherMap = myMap;`                                                           | 构建一个与另一个映射相同的映射                                                                                                                                    |
| `Constructor: map<K, V>(InputIterator start, InputIterator stop)`                                        | `map<string, int> myMap(myVec.begin(), myVec.end());`                                            | 构建一个包含指定范围 `[start, stop)` 中元素副本的映射。任何重复的元素都会被丢弃，并且元素会被排序。并且，此函数接受来自任何来源的迭代器，但它们必须是键值对迭代器 |
| `size_type size() const`                                                                                 | `int numEntries = myMap.size();`                                                                 | 返回映射中包含的元素数量                                                                                                                                          |
| `bool empty() const`                                                                                     | `if(myMap.empty()) { ... }`                                                                      | 返回`map`是否为空                                                                                                                                                 |
| `void clear()`                                                                                           | `myMap.clear();`                                                                                 | 清空`map`                                                                                                                                                         |
| `iterator begin() const_iterator begin() const`                                                          | `map<int>::iterator itr = myMap.begin();`                                                        | 返回到映射开始的迭代器                                                                                                                                            |
| `iterator end() const_iterator end()`                                                                    | `while(itr != myMap.end()) { ... }`                                                              | 返回一个迭代器，指向映射中最后一个元素之后的元素                                                                                                                  |
| `pair<iterator, bool> insert(const pair<const K, V>& value)`                                             | `myMap.insert(make_pair("STL", 137));`                                                           | 第个版本将指定的键/值对插入到映射中。返回类型是一个包含对元素的迭代器和表示元素是否成功插入（true）或已存在（false）的布尔值的对                                  |
| `void insert(InputIterator begin, InputIterator end)`                                                    | `myMap.insert(myVec.begin(), myVec.end());`                                                      | 第二次版本将指定的元素范围插入到映射中，忽略重复项                                                                                                                |
| `V& operator[] (const K& key)`                                                                           | `myMap["STL"] = "is awesome";`                                                                   | 如果存在，返回与指定键关联的值。如果不存在，将创建一个新的键/值对，并将值初始化为零（如果是原始类型）或默认值（对于非原始类型）。                                 |
| `iterator find(const K& element) const_iterator find(const K& element) const`                            | `if(myMap.find(0) != myMap.end()) { ... }`                                                       | 如果存在指定键的键/值对，返回一个该键值对的迭代器，否则返回`end`迭代器                                                                                            |
| `size_type count(const K& item) const`                                                                   | `if(myMap.count(0)) { ... }`                                                                     | 如果映射中存在具有指定键的键/值对，返回 1，否则返回 0                                                                                                             |
| `size_type erase(const K& element) void erase(iterator itr); void erase(iterator start, iterator stop);` | `if(myMap .erase(0)) {...} myMap.erase(myMap.begin()); myMap.erase(myMap.begin(), myMap.end());` | 删除元素，或迭代器对应的元素，以及迭代器范围内的元素                                                                                                              |
| `iterator lower_bound(const K& value)`                                                                   | `itr = myMap.lower_bound(5);`                                                                    | 返回一个迭代器，指向第一个键/值对，其键大于或等于指定的值                                                                                                         |
| `iterator upper_bound(const K& value)`                                                                   | `itr = myMap.upper_bound(100);`                                                                  | `返回一个迭代器，该迭代器指向第一个键/值对，其键大于指定的值`                                                                                                     |

### 实例：关键词计数器

[具体代码实现](关键词计数器实例)  
效果：

```txt
Enter filename: keyword_counter.cpp
Keyword and occurred 1 times.
Keyword for occurred 6 times.
Keyword if occurred 3 times.
Keyword int occurred 1 times.
Keyword namespace occurred 1 times.
Keyword operator occurred 2 times.
Keyword or occurred 1 times.
Keyword return occurred 4 times.
Keyword true occurred 1 times.
Keyword using occurred 1 times.
Keyword void occurred 3 times.
Keyword while occurred 4 times.
```

### Multicontainers

STL 提供了多容器类，即`multimap`和`multiset`，它们存储的值/键可以不唯一  
语法和`map`/`set`相同，函数略有不同  
_count()_ 返回元素在容器中的数量，不仅仅是 0 或 1  
_find()_ 返回一个指向该元素的迭代器，但不保证唯一  
_erase()_ 将删除该键/值的所有副本

`multimap`中`myMap[key] = value`方括号的方式不再有效，需要用`insert`函数插入

对于多容器有用的函数：  
_equal_range()_ 返回一个`pair<iterator, iterator>`,表示等于指定值的范围  
eg:遍历`multimap`中所有键等于`STL`的条目

```c++
pair<multimap<string, int>::iterator, multimap<string, int>::iterator>
	myPair = myMultiMap.equal_range("STL");
for(multimap<string, int>::iterator itr = myPair.first;
	itr != myPair.second; ++itr)
	cout << itr->first << ": " << itr->second << endl;
```

### 拓展： 确定有限自动机

确定有限自动机`DFA`（_Deterministic Finite Automata_）

> 是一种处理信息和识别模式的数学模型。它由一个有限的状态集合和一组转换规则组成，这些规则定义了在给定输入下状态之间的转换

状态图：  
![](../../../public/DFA_pic1.png)
**在结束时处于双圈内，才接受输入**  
此 DFA 接受至少包含一个 0 和一个 1 的字符串  
![](../../../public/DFA_pic2.png)
此 DFA 接受所有包含奇数个 0 或奇数个 1 的字符串  
一个 DFA 由下面 5 条信息表示：

1. DFA 使用的状态集合
2. DFA 的字母表
3. 初始状态
4. 状态转换
5. 接受状态集合  
   第 1、2、4 可以用表格表示：  
   给定当前状态和输入符号要转换到的状态

| 状态  | 0     | 1     |
| ----- | ----- | ----- |
| $q_0$ | $q_1$ | $q_2$ |
| $q_1$ | $q_0$ | $q_3$ |
| $q_2$ | $q_3$ | $q_0$ |
| $q_3$ | $q_2$ | $q_1$ |

[代码实现](确定有限自动机.md)

### 非确定有限自动机

_NFA_ (`nondeterministic finite automaton`)  
不同于 _DFA_ ,NFA 中的状态可以有任意数量的转换（包括 0)  
![](../../../public/NFA_pic1.png)
如图在$q_0$处有两个`0`和两个`1`状态  
有两种解释：

- 非确定性地选择一条路径
- 同时处于不同的状态  
  [具体代码实现](非确定有限自动机.md)  
  与 _DFA_ 的区别在于`map`改为`multimap`，对应可以有多种选择路径

### more to explore

- list ：列表，链表实现的顺序容器
- Boost ：用于增强原生库支持的函数和类，例如`unordered_set`和`unordered_map`使用哈希而不是树结构存储数据

## STL Algorithms

优点：

- 简单性
- 正确性
- 速度
- 清晰性

### 累加

头文件`<numeric>`
_accumulate(itr, itr, value)_ 输入两个定义范围的迭代器，和初始值

### 算法命名规范

- 后缀`_if` 在满足某种情况时执行函数  
  如 _count_if(itr, itr, bool)_  
  相比 _count(itr, itr, value)_ 统计范围中等于该值的次数  
  该函数在 bool 函数为`true`时计数

```c++
bool IsEven(int value)
{
	return value % 2 == 0;
}

cout << counr_if(myVec.begin(), muVec.end(), IsEven) << endl;
```

- 包含`copy` 将结果存储在额外位置  
  如 _remove_copy()_ _partial_sort_copy()_
- 以`_n`结尾 执行某操作 n 次  
  如 _genetrate_n()_ _search_n()_  
  相比 _fill(itr, itr, value)_ 在范围内填充为 value  
  _fill_n(itr, cnt, value)_ 以一个迭代器为开始填充 cnt 个数

```c++
fill(myDeque.begin(), myDeque.end(), 0);
fill_n(myDeque.begin(), 10, 0);
```

### 迭代器类别

在`vector`和`deque`中为了指定某个元素的迭代器，可以使用`myVec.begin()+n`的语法  
但在`map`及`set`中`+`运算符被禁止，防止效率低下

- 输出迭代器 只能写入值 `*myItr = value` 可以用`++`向前移动
- 输入迭代器 只能读取值 `value = *myItr`
- 前向迭代器 结合了输出和输入迭代器 但只能向前`++` 不能`--`
- 双向迭代器 包含了前向迭代器的功能 此外可以用`--` 但不能`+`及`+=` 是` map` `set `使用的迭代器
- 随机访问迭代器 包含了最多的功能 是`vector`和`deque`使用的迭代器  
  ![](../../../public/iterator_category.png)

### 排序算法

_sort(itr, itr)_ 对范围内元素按升序排序 迭代器必须是随机访问迭代器  
可以指定一个比较函数，自定义排序方式

```c++
struct placeT
{
	int x;
	int y;
};

bool cmp(placeT one, placeT two)
{
	if(one.x != two.x)
		return one.x < two.x;
	return one.y < two.y;
}

sort(myPlaceVecor.begin(), myPlaceVecor.end(), cmp);
```

_random_shuffle(itr, itr)_ 随机打乱元素位置，不需要传递比较函数  
迭代器也必须是随机访问迭代器  
函数内部使用`rand()`生成随机数，因此在使用函数前应该使用`srand()`初始化

_rotate(itr, itr+n, itr)_ 对范围内元素循环 接受开始、中间、结束迭代器  
`rotate(v.begin(), v.begin() + 2, v.end())`  
会对`(0, 1, 2, 3, 4, 5)`围绕第三个元素`2`循环，结果`(2, 3, 4, 5, 0, 1)`

### 搜索算法

虽然`set`和`map`自然支持查找，但`vector`和`deque`缺少这种功能  
_find(itr, itr, value)_ 在范围内查找值，如果找到返回范围内第一个具有该值的迭代器，如果没有返回第二个迭代器

```c++
if(find(myVector.begin(), myVector.end(), 137) != myVector.end())
/* ... vector contains 137 ... */
```

::: tip tip
如果一个容器类有一个和算法同名的成员函数，应该尽可能使用成员函数，成员函数有针对性的优化，速度快
:::
_binary_search(itr, itr, bool)_ 和 sort 类似，如果使用特殊比较函数排序，也该使用该函数作为参数  
该函数不返回迭代器，只是检查是否在容器中，如果想获取迭代器，可以使用 _lower_bound()_

### 迭代适配器

头文件`<iterator>`  
是类似迭代器的对象，可以用`*`解引用，并用`++`向前推进，但实际并不指向容器中的元素
比如：

```c++
ostream_iterator<int> myItr(cout, " ");
*myItr = 137;
++myItr;
*myItr = 42;
++myItr;
```

这段代码会输出`137 42`  
给迭代器解引用赋值后会写入到`cout`中  
迭代适配器本身就是迭代器，可以和 STL 算法一起使用，用来"欺骗“算法  
例如：  
_copy(itr, itr, itr3)_ 会复制范围内的元素到新的迭代器指向的目标

```c++
copy(myVector.begin(), myVector.end(), ostream_iterator<int>(cout, " "));
```

这段代码会将`myVector`的内容打印出来

特殊迭代器适配器：插入迭代器 （是输出迭代器）  
使用`insert`、`push_back`或`push_front`函数将值插入到容器中  
例如：_back_insert_iterator()_ 会调用`push_back`来存储值

```c++
vector<int> myVector;
back_insert_iterator<vector<int>> itr(myVector);
//写入itr的任何值将通过调用push_back存储在myVector
for(int i = 0; i< 10; ++i)
{
	*itr = i; //隐式调用myVector.push_back(i)
	++itr;
}
copy(myVector.begin(), myVector.end(), ostream_iterator<int>(cout, " "));
```

这种迭代器几乎仅作为需要储存结果位置参数的 STL 算法使用  
例如：假设我们想使用`reverse_copy`来制作一个与原始顺序相反的副本

```c++
vector<int> original = {...};
vector<int> destination;
reverse_copy(original.begin(), original.end(), back_insert_iterator<vector<int>>(destination));
```

`back_insert_iterator<vector<int>>(destination));`可以简写为：  
`back_inserter(destination);`

_set_union()_ 、_set_intersection()_ 、_set_difference()_  
是计算并集、交集、差集的函数，接受五个参数：两个迭代器范围对，以及一个最终位置迭代器

```c++
set<int> result;
set_union(setOne.begin(), setOne.end(),
	setTwo.begin(), setTwo.end(),
	inserter(result, result.begin()));
```

_inserter(result, result.begin())_ 插入迭代器，将元素插入结果集中  
_istream_iterator()_ 输入迭代器 可以从流中读取值  
改进本章最开始的计算平均数函数：

```c++
copy(istream_iterator<int>(input), istream_itetator<int>(),
	inserter(values, values.begin()));
```

迭代器适配器函数表：  
![](../../../public/table_of_iterator_adapt.png)

### 移除算法

_remove(itr, itr, value)_ 会将容器的内容向下移动来覆盖需要删除的元素，==并不是真正删除== ，返回一个指向第一个不在修改范围内的元素的迭代器  
如果想真正删除：  
`myVector.erase(remove(myVector.begin(), myVector.end(), 137), myVector.end());`

### 其他值得注意的算法

_transform(itr_start, itr_end, itr_start_new, function)_ 输入一个范围，将范围内的每个元素经过处理后输出给目标迭代器  
例如：将字符串转小写

```c++
string to_lower(string text)
{
    transform(text.begin(), text.end(), text.begin(), ::tolower);
    //兼容性问题：有两个tolower函数，编译器无法区分，使用：：明确使用的是<cctype>的原始的函数
    return text;
}
```

常用 STL 函数列表：

| 函数声明                                                                                                                 | 描述                                                                                                              |
| ------------------------------------------------------------------------------------------------------------------------ | ----------------------------------------------------------------------------------------------------------------- |
| `Type accumulate(InputItr start,InputItr stop,Type value)`                                                               | 返回`[start, stop)`范围内的元素的总和加上 Value 的值                                                              |
| `bool binary_search(RandomItr start,RandomItr stop,const Type& value)`                                                   | 二分搜索，返回是否在范围内找到 value,如果使用特殊比较函数，将该函数指定为最后的参数                               |
| `OutItr copy(InputItr start,  InputItr stop,  OutItr outputStart)`                                                       | 将范围内的元素复制到输出迭代器，返回指向写入范围末尾的迭代器                                                      |
| `size_t count(InputItr start,InputItr end,const Type& value)`                                                            | 返回在范围内等于 value 的数量                                                                                     |
| `size_t count_if(InputItr start,  InputItr end,  PredicateFunction fn)`                                                  | 返回在范围内 fn 函数为 true 的元素数量                                                                            |
| `bool equal(InputItr start1,  InputItr stop1,  InputItr start2)`                                                         | 返回范围内元素和另一个开始范围内元素是否相等                                                                      |
| `pair<RandomItr, RandomItr>  equal_range(RandomItr start,  RandomItr stop,  const Type& value)`                          | 返回一对迭代器，定义了一个范围，在范围内的元素都等于 value                                                        |
| `void fill(ForwardItr start,  ForwardItr stop,  const Type& value)`                                                      | 将范围内的元素都设置为 value                                                                                      |
| `void fill_n(ForwardItr start,  size_t num,  const Type& value)`                                                         | 将从开始的 n 个元素设置为 value                                                                                   |
| `InputItr find(InputItr start,  InputItr stop,  const Type& value)`                                                      | 返回一个迭代器，指向范围内第一个等于 value,如果没有，指向 stop                                                    |
| `InputItr find_if(InputItr start,  InputItr stop,  PredicateFunc fn)`                                                    | 指向第一个使 fn 为真的元素                                                                                        |
| `Function for_each(InputItr start,  InputItr stop,  Function fn)`                                                        | 将范围内每个元素输入 fn 函数                                                                                      |
| `void generate(ForwardItr start,  ForwardItr stop,  Generator fn);`                                                      | 对范围内每个元素调用 fn 函数，并将返回值存储在该范围内                                                            |
| `void generate_n(OutputItr start,  size_t n,  Generator fn);`                                                            | 调用 fn 函数 n 次，并将结果存储在以 start 开头的范围内                                                            |
| `bool includes(InputItr start1,  InputItr stop1,  InputItr start2,  InputItr stop2)`                                     | 返回范围`[start2, stop2)`内的每个元素也在范围内 1 中                                                              |
| `Type inner_product(InputItr start1,  InputItr stop1,  InputItr start2,  Type initialValue)`                             | 计算`[start1,stop1）`和`[start2, start2+(stop1-start1))`范围内积与初始值的和，$\sum_{i=1}^{n}a_ib_i+initialValue$ |
| `bool  lexicographical_compare(InputItr s1,  InputItr s2,  InputItr t1,  InputItr t2)`                                   | 返回由`[s1, s2)`定义的元素范围是否在字典顺序上小于`[t1, t2)`范围                                                  |
| `InputItr  lower_bound(InputItr start,  InputItr stop,  const Type& elem)`                                               | 返回大于等于元素的第一个元素的迭代器                                                                              |
| `InputItr max_element(InputItr start,  InputItr stop)`                                                                   | 返回指向范围内最大值的迭代器                                                                                      |
| `InputItr min_element(InputItr start,  InputItr stop)`                                                                   | 返回指向范围内最小值的迭代器                                                                                      |
| `bool next_permutation(BidirItr start,  BidirItr stop)`                                                                  | 在范围内修改排序，如果能生成下一个排序返回 true, 通常和`do while`搭配使用打印字典序                               |
| `bool prev_permutation(BidirItr start,  BidirItr stop)`                                                                  | 和上一个函数方向相反                                                                                              |
| `void random_shuffle(RandomItr start,  RandomItr stop)`                                                                  | 随机排序范围内的元素                                                                                              |
| `ForwardItr remove(ForwardItr start,  ForwardItr stop,  const Type& value)`                                              | 删除范围内所有等于 value 的元素，此函数并不会从容器中删除，想真正删除，使用`erase(remove(...), end())`            |
| `ForwardItr  remove_if(ForwardItr start,  ForwardItr stop,  PredicateFunc fn)`                                           | 如果 fn 返回 true 则删除                                                                                          |
| `void replace(ForwardItr start,  ForwardItr stop,  const Type& toReplace,  const Type& replaceWith)`                     | 替换等于 toPelace 的值为 replaceWith                                                                              |
| `void replace_if(ForwardItr start,  ForwardItr stop,  PredicateFunction fn,  const Type& with)`                          | 当 fn 为 true 是替换                                                                                              |
| `ForwardItr rotate(ForwardItr start,  ForwardItr middle,  ForwardItr stop)`                                              | 旋转容器中的元素，使`[middle, stop)`位于前面，范围`[start, middle)`到末尾，返回 start 的新位置的迭代器            |
| `ForwardItr search(ForwardItr start1,  ForwardItr stop1,  ForwardItr start2,  ForwardItr stop2)`                         | 返回`[start2, stop2)`是否是`[start1, stop1)`的子序列                                                              |
| `InputItr set_difference(  InputItr start1,  InputItr stop1,  InputItr start2,  InputItr stop2,  OutItr dest)`           | 存储在范围 1 不在范围 2 的元素到 dest                                                                             |
| `InputItr set_intersection(  InputItr start1,  InputItr stop1,  InputItr start2,  InputItr stop2,  OutItr dest)`         | 存储两个范围都存在的元素到 dest                                                                                   |
| `InputItr set_union(  InputItr start1,  InputItr stop1,  InputItr start2,  InputItr stop2,  OutItr dest)`                | 存储两个范围出现的元素到 dest                                                                                     |
| `InputItr set_symmetric_difference(  InputItr start1,  InputItr stop1,  InputItr start2,  InputItr stop2,  OutItr dest)` | 存储对称差（只在其中一个出现）                                                                                    |
| `void swap(Value& one, Value& two)`                                                                                      | 交换值                                                                                                            |
| `ForwardItr swap_ranges(ForwardItr start1, ForwardItr stop1, ForwardItr start2)`                                         | 交换范围内的每个元素与从 start2 开始的对应元素                                                                    |
| `OutputItr transform(InputItr start,  InputItr stop,  OutputItr dest,  Function fn)`                                     | 将范围内的元素传给 fn 函数，结果存储在 dest                                                                       |
| `RandomItr  upper_bound(RandomItr start,  RandomItr stop,  const Type& val)`                                             | 返回第一个严格大于 val 的值的迭代器                                                                               |

### 拓展示例：回文

简单遍历，逐个判断：

```c++
bool IsPalindrome(string input)
{
	for(int k = 0; k < input.size() / 2; ++k)
	{
		if(input[k] != input[input.length() - 1 - k])
			return false;
	return true;
	}
}
```

复制逆序副本：

```c++
bool IsPalindrome(string input) {
	string reversed = input;
	reverse(input.begin(), input.end());
	return reversed == input;
}
```

用反向迭代器：

```c++
bool IsPalindrome(string input) {
	return equal(input.begin(), input.begin() + input.size() / 2,	input.rbegin());
}
```

最终版本：不考虑大小写和符号：

```c++
bool IsPalindrome(string input) {
	input.erase(remove_if(input.begin(), input.end(), IsNotAlpha),input.end());
	transform(input.begin(), input.end(), input.begin(), ::toupper);
	return equal(input.begin(), input.begin() + input.size() / 2, input.rbegin());
}
```

如果以单词为界限判断是否是回文：

```c++
bool IsWordPalindrome(string input) {
	input.erase(remove_if(input.begin(), input.end(), IsNotAlphaOrSpace),  		input.end());
	transform(input.begin(), input.end(), input.begin(), ::toupper);

	stringstream tokenizer(input);
	vector<string> tokens;

	tokens.insert(tokens.begin(),
		istream_iterator<string>(tokenizer),
		istream_iterator<string>());
	return equal(tokens.begin(), tokens.begin() + tokens.size() / 2,
			tokens.rbegin());
}
```

### More to Explore

- `<cctype>` 用于对字符进行分类和格式转换
- `<cmath>` C 数学库
- `Boost Algorithms` Boost C++库

## Data Abstraction

## Abstraction and Classes 类

类是一个与实现配对的接口，一个类的结构可以分为两部分

- 公共接口指定客户端如何与类交互
- 私有实现指定公共接口中的函数如何实现  
  C++通过公共、私有关键字实现强制封装`public` `private`

`assert`断言，方便调试，头文件`<cassert>`

```c++
void class_name::setValue(int new_value)
{
	assert(new_value >= 0); 保证括号内的内容为true才能进行下去，否则终止
	value = new_value;
}
```

类实例：

```cpp
class FMRadio
{
	public:
	FMRadio();
    double getFrequency();
    void setFrequency(double newFre);

	private:
	double frequency;  //class中不允许直接初始化值，可以靠构造函数初始化
	int volume;
};

//在class外实现：
double FMRadio::getFrequency()
{

}
FMRadio::FMRadio()
{

}
```

#### 构造函数

类中在创建实体后执行的操作  
构造函数不需要返回值  
构造函数不能相互调用

```c++
class FMRadio
{
	public:
	FMRadio();
	FMRadio(double fre, int vol); //带参数的构造函数

};


FMRadio::FMRadio()
{
}
FMRadio::FMRadio(double fre, int vol)
{
}

int main()
{
	FMRadio myRadio;
	FMRadio myRadio(); //错误，这会被认为是创建一个函数原型，返回类型是FMRadio类型，而不是创建一个变量使用默认构造函数
}
```

> [!note]  
> 如果没有构造函数，C++会提供一个默认的构造函数，但凡有一个构造函数（不论有无参数），C++就不会提供构造函数，可以利用这点使一个没有无参构造函数的类，使得使用时必须用有参构造函数创建变量

#### 划分文件(分离实现和接口)

声明放在.h 文件，实现放在.cpp 文件  
使用时先`#include"**.h"`

### 模板类(template)

模板是进一步的抽象，比如`vector`可以根据需要存储各种数据

> 类模板是一个有洞的类，当客户端使用模板类时，她会填充这些洞以得到一个完整的类型

eg:创建一个自己的`pair`类型

```c++
template<typename one, typename two> struct MyPair
{
    one first;
    two second;
};

Mypair<int, string> one;
one.first = 0;
one.second = "yep";
```

> [!tip]  
> 在这里，typename 也可以用 class 代替，但具有一定误导性，实际上是完全等价的，用 int、double 类型实例化也是可以的

在模板类外实现函数：

```c++
template<typename FirstType, typename SecondType>
    FirstType MyPair<FirstType, SecondType>::getFirst()
    {
        return first;
    }
```

也可以声明的时候直接实现：

```c++
template<typename FirstType, typename SecondType> class MyPair
{
public:
    FirstType getFirst()
    {
        return first;
    }
    void setFirst(FirstType newValue)
    {
        first = newValue;
    }

    SecondType getSecond()
    {
        return second;
    }
    void setSecond(SecondType newValue)
    {
        second = newValue;
    }

private:
    FirstType first;
    SecondType second;
};
```

> [!tip]  
> 创建模板类的.h 文件时需要注意，和类不同，模板类的声明和实现要放在同一个文件内，否则编译器无法将另一个文件的模板替换

一个需要注意的点：在模板内嵌套使用其他类型，（例如使用`deque<T>`内部嵌套的迭代器类型），必须要在该类型前加上`typename`  
在模板中，编译器无法确定  `iterator`  是类型还是静态成员，`typename`  明确指出这是一个类型。

```c++
deque<T>::iterator begin(); // problem: Illegal syntax.
typename deque<T>::iterator begin(); // right
```

### 常量 const

```c++
const int myConstant = 137;
```

常量可以确保一个变量不能再被修改，如果修改会报错

当类还有成员函数时，编译期无法确定这个函数是否会对变量修改  
所以，`const`另一种用法：

```c++
class string
{
public:
	size_t length() const; //表示不会对变量造成修改
};

size_t string::length() const
{
	...
}
```

> [!note]  
> 标记构造函数为 const 不合法

在函数传参时，通常会使用引用(`references`),避免重复拷贝  
但这使函数是否会对变量修改变得不清晰，因此我们可以使用常量引用

```c++
void PreintVector(const vector<int>& vec); //这表示不会引用的变量进行修改，在函数内部当成常量看待
```

> [!note]  
> 我们可以将任意变量传给设定参数为`const`的函数，但不能将`const`变量传进非`const`的函数

一些错误传参例子：

```c++
void DoSomething(int& x);

DoSomething(137); //137是常量，不能修改
DoSomething(2.71828); //同上

double myDouble;
DoSometing(myDouble); //存在隐式转换，不被允许

void DoSomething(const int& x); //如果是这样上述三种情况就都合法
```

#### 常量与指针

==常量指针==(`pointer-to-const`指向常量的指针)`cnost`在`*`左边  
可以重新分配 const 指针，但不能更改它们指向的元素值

> 类比望远镜，可以转移观察对象，但不能对对象做出更改

```c++
const Type* myPointer；//格式
Type const* myPointer;//格式2

const char* st = "this is string ";
    st[0] = 'L'; //error 不可以更改指向的元素值
    st = "changed!"; //right 可以重新分配指针
```

==指针常量==(`const pointer`)`cosnt`在`*`右边  
不可以重新分配指针，可以更改它们指向的元素值

> 类比工业激光器，可以切割金属板，但光束始终指向同一个地方

```c++
Type* const myPointer://格式

char* const stt = "this is string";
    stt[0] = 'L'; //right  可以更改指向的元素值
    stt = "changed!"; //error 不可以重新分配指针
```

==常量指针常量==(`const pointer-to-const`)`const`在`*`两边  
既不可以重新分配指针，也不可以更改它们指向的元素值

```c++
const Type* const myPointer; //格式
Type const* const myPointer; //格式2

const char* const stt = "this is string";
    sttt[0] = 'L'; //error 不可以更改指向的元素值
    sttt = "changed!"; //error 不可以重新分配指针
```

表格：

| 语法                      | 名称         | 能否重新分配 | 能否修改指向元素 |
| ------------------------- | ------------ | ------------ | ---------------- |
| `const Type* myPtr`       | 常量指针     | ✅           | ❌               |
| `Type const* myPtr`       | 常量指针     | ✅           | ❌               |
| `Type* const myPtr`       | 指针常量     | ❌           | ✅               |
| `const Type* const myPtr` | 常量指针常量 | ❌           | ❌               |
| `Type const* const myPtr` | 常量指针常量 | ❌           | ❌               |

> [!tip]  
>  `const`是保守的，分析是不精确的，它不是确定代码是否实际修改了`const`变量，而是检查：  
> 是否对一个`const`变量赋值  
> 是否在一个`const`变量上调用非`const`函数  
> 是否将一个`const`变量传递给一个通过非`const`引用接收参数的函数

#### 常量迭代器(`const_iterator`)

一个错误的例子：

```c++
void PrintVector(const vector<string>& myVector)
{
	for(vector<string>::iterator itr = myVector.begin(); itr != myVector.end(); ++itr)
		cout << *itr << endl; //在const变量上使用的非const迭代器
}
```

如果只是给迭代器加上`const`，效果类似指针常量——不能改变迭代的对象，但可以修改对象的值，与我们想要的相反  
因此正确的是使用`const_iterator`迭代器

```c++
for(vector<string>::const_iterator itr = myVector.begin(); itr != myVector.end(); ++itr) //correct
		cout << *itr << endl;
```

#### 常量重载

根据变量是否是常量，调用对应的函数

```c++
class Vector
{
public:
    int *rawElems();

    const int *rawElems() const;

private:
    int *elems;
};

int *Vector::rawElems()
{
    return elems;
}
const int *Vector::rawElems() const
{
    return elems;
}
```

> [!warning]  
> const 函数不应该返回允许修改对象内部状态的指针

#### mutable(可变)

在某些情况下，标记为`const`的成员函数可能会修改到变量，但又符合不修改变量的本意(比如：在 get 函数中延迟获取数据)

```c++
class GroceryList
{
public:
    GroceryList(const string &filename);
    string getItemAt(int index); // Problem: No longer const
private:
    vector<string> data;
    ifstream sourceStream;
};
GroceryList::GroceryList(const string &filename)
{
    sourceStream.open(filename.c_str()); // Open the file.
}
string GroceryList::getItemAt(int index)
{
    while (index >= data.size())
    {
        string line;
        getline(sourceStream, line);
        data.push_back(line);
    }
    return data[index];
}
```

此时可以使用`mutable`修饰变量，表示这个变量可以在`const`函数中被修改

```c++
class GroceryList
{
public:
    GroceryList(const string &filename);
    string getItemAt(int index) const;
private:
    mutable vector<string> data;
    mutable ifstream sourceStream;
};
```

`mutable`应谨慎使用，否则可能违背`const`本意

#### `const`正确性原则

- 对象永远不会按值传递。任何本应按值传递的对象，实际上是通过常量引用或常量指针传递的。
- 成员函数如果不改变状态则标记为 `const`。同样，未标记为`const`的函数应以某种方式改变状态。
- 变量被设置但从未修改的会被标记为`const`再次强调，未标记为`const`的变量应该在某个时刻改变其值。

### 成员初始化列表(`Member Initializer Lists`)

```c++
class SimpleClass
{
public:
    SimpleClass();

private:
    int myInt;
    string myString;
    vector<int> myVector;
};
SimpleClass::SimpleClass()
{
    myInt = 5;
    myString = "C++!";
    myVector.resize(10);
}
```

创建实例后初始数据是内存中随机的一块，然后先是调用变量的默认构造函数，原始类型`int`不变，`string`变为空字符串，`vector`清空  
再调用构造函数初始化，用成员初始化列表可以一步到位

```c++
SimpleClass::SimpleClass() : myInt(5), myString("C++!"), myVector(10) {
}
```

还可以参数化构造函数

```c++ {4}
class doSome
{
public:
	doSome(int num = 0, int den = 1);
	//如果前面一个参数设置了默认值后面的参数也必须要有默认值
	// 这一个构造函数相当于提供了多个版本：
	doSome();           // 无参版本
	doSome(int num);    // 单参版本
	doSome(int num, int den); // 双参版本
private：
	int num;
	int den;
};

doSome::doSome(int num, int den):num(num), den(den)
{
}

int main()
{
	doSome myDo;        // 使用默认值：num=0, den=1
	doSome myDo1(12, 13); // 指定两个参数：num=12, den=13
	doSome myDo2(12);   // 指定第一个参数，第二个使用默认值：num=12, den=1
}
```

> [!tip]  
> 应当在声明和实现其中一个设定默认值，如果都设定了默认值，编译期会报错
> 常变量必须使用初始化列表初始化

### 静态`static`

#### 静态数据成员

一个类的所有实例共用同一个静态变量，当静态变量被修改时，所有实例同步，可以达到共用的目的  
静态数据成员必须在所在类内部声明，并在与该类关联的.cpp 文件内部定义  
如果定义为`private`，依然可以在类外定义（当且仅当定义时）  
定义：

- 必须使用其完全限定名
- 不要重复使用静态关键字

```c++
class MyClass {
public:
	void doSomething();
private:
	static int myStaticData; //声明
};

int MyClass::myStaticData;//定义
```

#### 静态成员函数

==this==指向当前类的指针

```c++
int x = pt.getX();
int x = Point::getX(&pt);
int Point::getX(Point *const this);
//三者等价，隐式有一个this参数
```

```c++
class Point
{
public:
    Point(int xLoc, int yLoc);
    int getX() const;
    int getY() const;
    static bool compareTwoPoints(const Point &one, const Point &two);

private:
    int x, y;
};
bool Point::compareTwoPoints(const Point &one, const Point &two)
{
    if (one.x != two.x)
        return one.x < two.x;
    return one.y < two.y;
}
int main()
{
    vector<Point> myVector;
    sort(myVector.begin(), myVector.end(), Point::compareTwoPoints);
    //sort需要的是传入两个参数的函数，用static取消了隐式的this
}
```

#### static 和 const

修改`static`变量的函数不影响被标记为`const`(`static`变量不属于特定实例)  
`static`函数不能再被标记为`const`（`static`函数没有`this`指针）  
==静态常量==不可被修改且实例中一致的变量

```c++
class ClassConstantExample {
public:

private:
	static const int MyConstant = 137; //变量是整型时，声明和定义可以放在一行
};
```

### 转换构造函数`Conversion Constructors`

C++自动将所有单参数构造函数视为转换构造函数

```c++
Vector<int> myVector = 137; //隐式转换, 转换构造函数
//等同于
Vector<int> myVector(137);
```

为了防止被视为转换构造函数，可以给构造函数添加显式`explicit`关键字

```c++
template <typename ElemType> class Vector
{
public:
	explicit Vector(int sizeHint = 10);
};

//这样再出现下面的情况，会报错
Vector<int> myVector = 137;
```

## Operator Overloading

运算符重载

> 即指定如何使通常适用于原始类型的运算符与自定义类交互

### 最小惊讶原则

函数的名称应传达其行为，并应与其他命名约定和习语保持一致。  
eg:定义一个有理数类，重载`+`运算符

```c++
class RationalNumber {
public:
	const RationalNumber operator+ (const RationalNumber& rhs) const;
};

int main()
{
	RationalNumber one, two;
	RationalNumber three = one + two;
	//将被编译器解释为：
	RationalNumber three = one.operator +(two);
}
```

如果考虑将`+`实现为接收两个参数的自由函数：

```c++ {5}
class RationalNumber {
public:
};

	const RationalNumber operator+ (const RationalNumber& lhs, const RationalNumber& rhs);

	RationalNumber one, two;
	RationalNumber three = one + two;
	//被解释为：
	RationalNumber three = operator+ (one, two);
```

### 减号和取反的实现

```c++
//减号：
const RationalNumber operator- (const RationalNumber& lhs, const RationalNumber& rhs);//自由函数
//成员函数
class RationalNumber {
public:
	const RationalNumber operator- (const RationalNumber& rhs) const;
};

//取反：
const RationalNumber operator- (const RationalNumber& arg); //自由函数
//成员函数
class RationalNumber {
public:
	const RationalNumber operator- () const;
};
```

### 实现不了的重载符

不能重载全新的符号(如`@`和`#`)

| 操作符                                                             | 语法              | 名称                              |
| ------------------------------------------------------------------ | ----------------- | --------------------------------- |
| `::`                                                               | `MyClass::value`  | 作用域解析                        |
| `.`                                                                | `one.value`       | 成员选择                          |
| `?:`                                                               | `a > b ? -1 : 1`  | 三目运算符                        |
| `.*`                                                               | `a.*myClassPtr`   | 指针成员选择                      |
| `sizeof`                                                           | `sizeof(MyClass)` | 对象尺寸                          |
| `typeid`                                                           | `typeid(MyClass)` | Runtime type information operator |
| `(T)` `static_cast` `dynamic_cast` `reinterpret_cast` `const_cast` | `(int) myClass`   | 类型转换                          |

### 左值和右值

左值可以在赋值语句左侧出现，右值只能出现在赋值语句的右侧

```c++
x = 5; //x是左值，5是右值
*itr = 137;

5 = 137; //error 右值只能在右侧
GetInteger() = x; //error GetInteger()返回的是右值

x = y; //左值可以在右侧
```

`(x + y）= 5；`无意义，所以要确保`+`返回的是右值  
`myArray[5] = 137;`要确保`operator[]`返回是左值

- 需要左值时可以返回非`const`引用  
  `string& LValueFunction();`  
  因为引用只是变量或内存位置的另一个名称，这个函数返回一个左值引用，其返回值可以被视为这样的引用
- 需要右值时返回`const`值  
  `const string RValueFunction();`  
  因为如果我们有一个返回 const 对象的函数，那么像这样的代码：  
  `RValueFunction() = 137;`是非法的，因为 `RValueFunction` 的返回值被标记为 `const`

### 元素选择运算符重载`[]`

```c++
for(int i = 0; i< myVector.size(); ++i)
{
	myVector[i] = 137;
	//相当于：
	myVector.operator [](i) = 137;
}

class string
{
public:
    /* ... */
    char &operator[](size_t position);
    const char &operator[](size_t position) const;
};
```

> [!tip]  
> 不能重载`[][]`运算符，可以通过代理对象技术实现（定义一个`operator[]`函数，该函数返回另一个对象，该对象本身重载了`operator[]`

### 复合赋值运算符重载

例如`+=、*=`运算符，成员函数原型：

```c++ {7,8}
MyClass& operator += (const ParameterType& param)

//实例：
class Vector3D
{
public:
j j j    Vector3D &operator +=(const Vector3D &other);
    const Vector3D operator- () const;//重载取负运算

private:
    static const int NUM_COORDINATES = 3;
    double coordinates[NUM_COORDINATES];
};

Vector3D &Vector3D::operator +=(const Vector3D &other)
{
    for(int i = 0; i< NUM_COORDINATES; ++i)
    {
        coordinates[i] += other.coordinates[i];
    }
    return *this;
}
```

### 数学运算符重载

加法和减法的重载

```c++ {3}
class Vector3D {
public:
	const Vector3D operator+ (const Vector3D& other);//右值类型

private:
	static const int NUM_COORDINATES = 3;
	double coordinates[NUM_COORDINATES];
};

const Vector3D Vector3D::operator +(const Vector3D& other) const
{
	Vector3d result = *this;
	result += other;
	return result;
}
```

假设有一个 3X3 的矩阵类`Matrix`，如果要重载`*`运算符，要将其定义为自由函数，c++总是会保留表达式中值的顺序

```c++
//确保myMatrix = 2.71828 * myMatrix有效
const Matrix operator * (double scalar, const Matrix& matrix)
{
	Matrix result = *matrix;
	matrix *= scalar;
	return result;
}

//确保myMatrix = myMatrix * 2.71828有效
const Matrix operator *(const Matrix& matrix, double scalar)
{
	return scalar * matrix; // Calls operator* (scalar, matrix)
}
```

> [!note]  
> 通常情况下，数学运算符如+应始终实现为自由函数

> [!tip]  
> 使用复合赋值运算符比使用独立的数学运算符要快得多
> 独立的数学运算符会创建临时的对象

### 重载`++`和`--`

`++`和`--`都有两个版本：前缀和后缀(`i++`和`++i`)

- `i++`需要存一个副本，i 自增后返回副本，是右值
- `++i`i 自增后直接返回自身，是左值  
  因此`++i`会比`i++`快(对于内置类型，两者性能几乎相同，现代编译器会优化掉差异)  
  重载时为了区分前缀和后缀，将前缀写成一个不接受任何参数的函数，后缀写成接受整数(无意义，仅为了区分，可以只写 int 不命名)参数的函数

```c++
class MyClass {
public:
/* ... */
	MyClass& operator ++(); // Prefix
	const MyClass operator ++(int dummy); // Postfix
private:
/* ... */
};

MyClass& MyClass::operator ++() {
	*this += 1;
	return *this;
}
const MyClass MyClass::operator ++(int dummy) {
	MyClass oldValue = *this; // Store the current value of the object.
	++*this;
	return oldValue;
}
```

### 关系运算符重载

```c++
class MyClass {
public:
	/* ... */
	bool operator < (const MyClass& other) const;
private:
	/* ... */
};
```

定义对象的`小于`必须满足：

- 三分法：对于任意的 a 和 b，a < b、a = b 和 b < a 中恰好有一个成立。
- 传递性：如果 a < b 且 b < c，那么 a < c。  
  定义了小于，就可以用小于定义其他关系操作符

| 关系     | 等价于                |
| -------- | --------------------- |
| `A < B`  | `A < B`               |
| `A <= B` | `!(B < A)`            |
| `A == B` | `!(A < B`\|\|`B < A)` |
| `A != B` | `A < B`\|\|`B < A`    |
| `A >= B` | `!(A < B)`            |
| `A > B`  | `B < A`               |

### 存储对象到 STL`map`中

STL 的`map`和`set`是基于关系运算符比较元素的二叉树构建的  
因此，要将自定义类存储在`map`或`set`中，只需重载`<`运算符

### `friend`关键字

`friend`可以给一个类访问及修改另一个类私有数据成员的权限  
`friend`声明必须在实现前面，否则编译器会报错

```c++
class MyClass {
public:
	/* ... */
	friend void ModifyMyClass(MyClass& param);
};
```

如果想要给一个模板类提供一个友元函数，友元声明中也需要提供模板声明

```c++ {9}
// 模板类 - 正确的友元声明
template <typename T>
class PQueue {
private:
    int size;
    T* data;

public:
    template <typename U> friend void PQueueFriend(const PQueue<U>& pq);
};

// 模板友元函数
template <typename T>
void PQueueFriend(const PQueue<T>& pq) {
    cout << "Size: " << pq.size << endl;  // 可以访问私有成员
}


```

### 流插入运算符重载

整个流库可以被视为一个巨大的重载`<<`和`>>`操作符的库  
流运算符应该返回流的的非`const`引用  
重载`point`类的流插入运算符：

```c++ {17}
class point
{
private:
    int x, y;

public:
    friend ostream& operator <<(ostream &stream, const point &pt);
    point(int x, int y)
    {
        this->x = x;
        this->y = y;
    }
};

ostream& operator << (ostream& stream, const point& pt)
{
    stream << '(' << pt.x << ", " << pt.y << ')';
    return stream;
}
```

### `*`和`->`重载

```c++
class PointerClass {
public:
	T& operator *() const;
	/* ... */
};
```

`->`是一个一元运算符，他应该返回一个指针，然后 C++编译器会自动在返回的指针上再次应用`->`

```c++
class CustomStringPointer {
private:
    string* ptr;

public:
    CustomStringPointer(string* p) : ptr(p) {}

    // operator-> 返回一个指针
    string* operator->() {
        cout << "CustomStringPointer::operator-> 被调用" << endl;
        return ptr;  // 返回实际的 string 指针
    }
};

//当写下：
myCustomPointer->length();
//编译器实际上将其转换为：
(myCustomPointer.operator->())->length()
```

这使得自定义类型可以模拟指针行为

| Operator          | Yields              | Usage                                                                                                                    |
| ----------------- | ------------------- | ------------------------------------------------------------------------------------------------------------------------ |
| `=`               | 左值                | `MyClass& operator =(const MyClass& other);`                                                                             |
| `+= -= *= /= %= ` | 左值                | `MyClass& operator +=(const MyClass& other);`                                                                            |
| `+ - * / %`       | 右值                | `const MyClass operator + (const MyClass& one, const MyClass& two);`这些操作符应定义为自由函数                           |
| `< <= == > >= !=` | 右值                | `bool operator < (const MyClass& other) const; bool operator < (const MyClass& one, const MyClass& two);`                |
| `[]`              | 左值                | `ElemType& operator [](const KeyType& key); const ElemType& operator [](const KeyType& key) const;`                      |
| `++ --`           | 前缀:左值 后缀:右值 | `MyClass& operator ++(); const MyClass operator ++(int dummy);`                                                          |
| `-`               | 右值                | `const MyClass operator -() const;`                                                                                      |
| `*`               | 左值                | `ElemType& operator *() const;`                                                                                          |
| `->`              | 左值                | `ElemType* operator ->() const;`                                                                                         |
| `<< >>`           | 左值                | `friend ostream& operator << (ostream& out, const MyClass& mc); friend istream& operator >> (istream& in, MyClass& mc);` |
| `()`              | 多种                |                                                                                                                          |

### 拓展示例：grid

`vector`的成员函数`assign`与`resize`类似，会改变向量的大小，但与 resize 不同，`assign` 会丢弃当前向量的所有内容，并用指定元素指定数量的副本替换它们。将 `ElemType()`作为 `assign` 的第二个参数意味着用存储类型的默认值填充向量（ `ElemType()`使用临时对象语法创建一个新的 `ElemType`）

```c++
elems.assign(rows * cols, ElemType());
```

网格类实例：  
[grid 类实例](grid类实例.md)

### More to Explore

- 重载`new`和`delete`
- 转换函数

## 资源管理

初始化是直接复制，赋值是清理后复制  
因为初始化和赋值是两个不同的任务，C++通过两个不同的函数来处理  
分别是==拷贝构造函数==和==赋值运算符==  
拷贝构造函数是一个单参数构造函数，接受引用到常量的类实例  
赋值运算符接受另一个类的 const 引用实例参数，返回类型对象的非 const 引用

```c++ {7， 8}
class MyClass
{
public:
	MyClass();
	~MyClass();

	MyClass(const MyClass& other); //复制构造函数
	MyClass& operator = (const MyClass& other); //赋值运算符
}
```

C++默认会自动为你编写的类提供一个基本的复制构造函数和赋值运算符，这些构造函数和赋值运算符会调用所有类数据成员的复制构造函数和赋值运算符

在某些情况下不会自动提供默认的拷贝构造函数和赋值运算符。

- 类包含引用或 const 变量作为数据成员，此类将不会自动获得赋值运算符。
- 如果类有一个没有拷贝构造函数或赋值运算符的数据成员（例如，ifstream），你的类将不可拷贝。
- 还有一个涉及继承的情况，C++不会自动创建拷贝函数。

### 三法则

定理：如果一个类具有以下三个成员函数之一

- 析构函数
- 复制构造函数
- 赋值运算符  
  然后那个类应该有这三个函数

推论：如果一个类有析构函数，它也应该有拷贝构造函数和赋值运算符

### 编写拷贝构造函数和赋值运算符

```c++
template <typename T>
class Vector
{
public:
    Vector();
    Vector(const Vector &other);            // Copy constructor
    Vector &operator=(const Vector &other); // Assignment operator
    ~Vector();

    typedef T *iterator;
    typedef const T *const_iterator;
    iterator begin();
    iterator end();
    const_iterator begin() const;
    const_iterator end() const;
    /* ... other member functions ... */
private:
    T *array;
    size_t allocatedLength;
    size_t logicalLength;
    static const size kStartSize = 16;
    void clear();
    void copyOther(const Vector &other);
};

template <typename T>
Vector<T>::Vector()
{
    allocatedLength = kStartSize;
    logicalLength = 0;
    array = new T[allocatedLength];
}

template <typename T>
Vector<T>::~Vector()
{
    clear();
}

template <typename T>
Vector<T>::Vector(const Vector &other)
{
    copyOther(other);
}

template <typename T>
Vector<T> &Vector<T>::operator=(const Vector &other)
{
    if (this != &other)
    {
        clear();
        copyOther(other);
    }
    return *this;
}

template <typename T>
void Vector<T>::copyOther(const Vector &other)
{
    logicalLength = other.logicalLength;
    allocatedLength = other.allocatedLength;

    array = new T[allocatedLength];
    copy(other.begin(), other.end(), array);
}

template <typename T>
void Vector<T>::clear()
{
    delete[] array;
}
```

### 通用框架

```c++
MyClass::MyClass() :
{
    /* Default initialization here. */
}
MyClass::MyClass(const MyClass &other)
{
    copyOther(other);
}
MyClass &MyClass::operator=(const MyClass &other)
{
    if (this != &other)
    {
        clear();
        copyOther(other);
    }
    return *this;
}
MyClass::~MyClass()
{
    clear();
}
```

### 禁用复制

可以提供一个赋值运算符和复制构造函数，但声明为私有，这样就可以禁止复制，并且不实现，这样如果在类成员内调用，会链接器错误

```c++
class CannotBeCopied {
public:
	CannotBeCopied();
/* Other member functions. */
private:
	//设置为私有
	CannotBeCopied(const CannotBeCopied& other);
	CannotBeCopied& operator = (const CannotBeCopied& other);
};


CannotBeCopied one;
CannotBeCopied two = one;// 这样就会报错
```

### 扩展示例：智能指针(SmartPointer)

更好管理内存，包含了普通指针，能够智能释放内存  
设计参考计数方案要点：

- 在创建用于管理新分配内存的智能指针时，首先创建一个中间对象，并使中间对象指向资源。然后，将智能指针附加到中间对象上，并将引用计数设置为 1。
- 为了使新的智能指针指向与现有智能指针相同的资源，让新的智能指针指向旧智能指针的中间对象，并增加中间对象的引用计数。
- 从资源中移除智能指针（无论是由于指针超出作用域还是因为正在重新分配），减少中间对象的重用计数。如果计数达到零，则释放资源和中介对象。

具体代码实现：  
[智能指针实例](智能指针实例.md)

## 错误处理

### 异常处理

C++提供了异常处理语言支持，可以绕过函数调用和返回，如果在函数内部发生错误，可以跳到错误处理代码  
语法有三部分：  
`try`指明可能发生错误的代码区域  
`throw`抛出异常信息到最近匹配的`catch`子句  
`catch`捕获错误，执行操作

```c++
catch(ParameterType param) {
	/* Error-handling code */
}
```

C++提供了一个头文件`<stdexcept>`，它定义了几个类，允许我们指定触发异常的错误类型  
其中`invalid_argument` 在其构造函数中接受一个字符串参数，该参数包含表示发生错误类型的消息，并且有一个名为 `what` 的成员函数，返回错误信息  
下面是一个将`string`类型数字转成`int`的函数例子：

```c++
#include <stdexcept>
#include <sstream>
#include <string>
#include <iostream>

using namespace std;

int StringToInteger(const string &input)
{
    stringstream converter(input);
    int result; // 尝试读取int,如果不能则失败
    converter >> result;
    if (converter.fail())
        throw invalid_argument("Cannot parse " + input + " as an integer.");

    char leftover; // 查看是否有剩余字符，有则失败
    converter >> leftover;
    if (!converter.fail())
        return result;
    else
        throw invalid_argument(string("Unexpected character: ") + leftover);
}

int main()
{
    string myString = "sdfa";
    try
    {
        int result = StringToInteger(myString);
        cout << "The result was: " << result;
    }
    catch (const invalid_argument &problem)
    {
        cout << problem.what() << endl; // Prints out the error message.
    }
    cout << "Yay! We're done." << endl;
}
```

可以在`catch`内再次抛出错误==捕获并重新抛出==

```c++ {7}
try{
	try {
		DoSomething();
	}
	catch(const invalid_argument& error) {
		cout << "Inner block: Error: " << error.what() << endl;
		throw error; // Propagate the error outward
	}
}
catch(const invalid_argument& error) {
cout << "Outer block: Error: " << error.what() << endl;
}
```

`catch(...)`可以捕获任何异常  
`throw;`可以抛出正在处理的当前异常

> [!warning]  
>  `throw;`必须用在`catch`块内部，否则程序会崩溃

因此在函数内部异常可以这么处理：

```c++
void SimpleFunction()
{
    int *myArray = new int[128];
    try
    {
        DoSomething(myCString);
    }
    catch (...)
    {
        delete[] myArray;
        throw;
    }
    delete [] myArray;
}
```

捕获并重新抛出的异常处理方法会导致代码变得相当复杂，在多数情况下，有更好的替代方案——==对象内存管理==

### 对象内存管理及 RAII

不同于其他语言，C++没有垃圾回收器，必须手动分配和释放内存  
头文件`<memory>`提供了`auto_ptr`模板类，构造函数接受一个动态分配的对象指针（比如  `new string`），当 auto_ptr 析构时，会自动调用  `delete`  释放内存，实现自动管理资源。

> [!note]  
> `auto_ptr`已被 C++11 的`unique_ptr`取代，因为它的所有权语义有缺陷（比如拷贝后原指针会变空）。

`auto_ptr` 调用 `delete`，而不是 `delete[]`，因此不能在 `auto_ptr` 中存储动态分配的数组(`new int[137]`),如果想要具有自动内存管理功能的数组，可以使用 `vector`  
`auto_ptr`拥有资源的唯一所有权，不会有多个智能指针共同拥有一个资源的情况  
`auto_ptr`模板类的成员函数列表：

| 成员函数原型                         | 例子                                                   |
| ------------------------------------ | ------------------------------------------------------ |
| `explicit auto_ptr (Type* resource)` | `auto_ptr<int> ptr(new int);`                          |
| `auto_ptr(auto_ptr& other)`          | `auto_ptr<int> one(new int); auto_ptr<int> two = one;` |
| `T& operator *() const`              | `*myAutoPtr = 137;`                                    |
| `T* operator-> () const`             | `myStringAutoPtr->append("C++!");`                     |
| `T* release()`                       | `int *regularPtr = myPtr.release();`                   |
| `void reset(T* ptr = NULL)`          | `myPtr.reset(); myPtr.reset(new int);`                 |
| `T* get() const`                     | `SomeFunction(myPtr.get());`                           |

通过构造函数和析构函数管理资源的系统通常被称为资源获取即初始化，简称 ==RAII==(`resource acquisition is initialization`)

### 异常和智能指针

在异常处理中可能会有内存泄露的情况，用智能指针管理可以避免：超出作用域时会自动回收内存

```c++
nodeT* GetNewCell() {
	auto_ptr<nodeT> newCell(new nodeT);
	newCell->next = NULL;
	newCell->data = SomeComplicatedFunction(); //这里可能抛出异常
	return newCell.release();
}
```

如果没有接收返回值，依然会内存泄露：

```c++
void SillyFunction() {
GetNewCell(); // Oh dear, there goes the return value.
}

//因此，返回智能指针类型：
auto_ptr<nodeT> GetNewCell() {
	auto_ptr<nodeT> newCell(new nodeT);
	newCell->next = NULL;
	newCell->data = SomeComplicatedFunction();
	return newCell;
}
```

> [!tip]  
> 对于可能在正常执行期间出现的错误，例如缺少文件或格式不正确的用户输入，应使用异常处理。对于表示软件编写错误时，`assert` 是一个更好的选择，如果 `assert` 失败，这意味着程序员犯了错误

> [!note]  
> 不要在`assert`断言中调用函数，大多数编译器在发布或优化构建中禁用断言，如果在断言中调用函数，在发布构建时函数不会被调用，导致调试和发布构建中的不同行为

### More to Explore

- The Standard Exception Classes
- Exception Specifications 异常规范
- Function `try` Bolcks 允许将函数的全部内容放入一个`try/catch`对中
- `new` and Exception 如果程序耗尽可用内存，`new` 运算符将通过抛出一个类型 `bad_alloc` 的异常来指示失败
- The Boost Smart Pointers

## Generic Programming

## Functors

`Functors`==仿函数==是 C++中一种行为像函数的对象，本质上是重载了`operator()`的类或结构体  
仿函数实例：

```c++
class Add {
    int operator()(int a, int b) const {
        return a + b;
    }
};

//使用时：
    Add add;
    cout << add(3, 5);
```

现在有一个实际的例子  
需求：一个函数 计算`vectot<string>`中长度小于某一个值的`string`数量  
`int numShort = count_if(v.begin(), v.end(), LengthIsLessThan);`  
`LengthIsLessThan()`只能接受一个参数，怎么传递需要比较的长度参数？  
使用仿函数可以实现这点：在类成员中增加长度参数

```c++
class ShorterThan {
public:
	explicit ShorterThan(size_t maxLength) : length(maxLength) {}
	bool operator() (const string& str) const {
	return str.length() < length;
	}
private:
	const size_t length;
};

//使用：
ShorterThan st(length);
count_if(myVector.begin(), myVector.end(), st);

//或是创建临时对象
count_if(myVector.begin(), myVector.end(), ShorterThan(length));
```

### 编写与 Functor 兼容的代码

```c++ {6}
const double kLowerBound = 0.0;
const double kUpperBound = 1.0;
const int kNumSteps = 25;
const double kStepSize = (kUpperBound - kLowerBound) / kNumSteps;

void TabulateFunctionValues(double function(double))
{
    for (double i = kLowerBound; i <= kUpperBound; i += kStepSize)
        cout << "f(" << i << ") = " << function(i) << endl;
}
```

上述代码，`TabulateFunctionValues`可以传入任意参数和返回都是`double`的函数，由传入的函数功能不同，`TabulateFunctionValues`输出的内容也就不同，可以使函数更灵活，同一个函数可以完成不同的任务  
现在我们如何将仿函数传进`TabulateFunctionValues`函数？  
`TabulateFunctionValues`需要的是函数指针，因此更改参数类型，传入仿函数实体，后面`function(i)`将调用 operator()函数：

```c++ {8}
class Reciprocal {
public:
	double operator() (double val) const {
		return 1.0 / val;
	}
};

void TabulateFunctionValues(Reciprocal function) {
	for(double i = kLowerBound; i <= kUpperBound; i += kStepSize)
	cout << "f(" << i << ") = " << function(i) << endl;
}
```

上述写法只能接收一种仿函数，使用模板可以解决这个问题：（可以支持仿函数、lambda、函数指针）

```c++
template <typename UnaryFunction>
void TabulateFunctionValues(UnaryFunction function)
{
	for(double i = kLowerBound; i <= kUpperBound; i += kStepSize)
		cout << "f(" << i << ") = " << function(i) << endl;
}
```

### 高阶编程

[Functors](#Functors)回到本章刚开始举的例子为了在`count_if(v.begin(), v.end(), bool_funtion);`中使用第二个参数,引出了`functor`  
但如果我们能够给`bool_function()`添加第二个参数（这个参数是锁定的），也就不用那么麻烦  
`<functional>`头文件提供了高级编程支持，导出了一些有用的函数，可以在运行时转换和修改函数，但由于语言的一些限制，`<functional>`库只能修改称为==可适配函数==的特殊构造函数

> [!tip]  
> 可适配函数在现代 C++被`lambda`表达式和`std::function`取代

任何一参数或二参数函数都可以轻松转换为等效的可适配函数  
一个辅助模板类`unary_function`：

```c++
template <typename ParameterType, typename ReturnType>
	class unary_function;
```

第一个模板参数表示函数参数的类型；第二个表示函数的返回类型

```c++
//原函数（一参数）：
class MyFunction {
public:
	bool operator() (const string& str) const
	{
	/* Function that manipulates a string */
	}
};

//可适配函数：
class MyFunction : public unary_function<string, bool> {
public:
	bool operator() (const string& str) const
	{
	/* Function that manipulates a string */
	}
};

//原函数（二参数）：
class MyOtherFunction {
public:
	bool operator() (const string& str, int val) const
	{
	/* Do something, return a bool. */
	}
};

//可适配函数：
class MyOtherFunction: public binary_function<string, int, bool> {
public:
	bool operator() (const string& str, int val) const
	{
	/* Do something, return a bool. */
	}
};
```

上述生成可适应函数的方法完全合法，但略显笨拙  
STL 函数库提供了一个功能强大但命名晦涩的 `ptr_fun` 函数  
`ptr_fun` 可以将一元和二元 C++函数转换为具有正确参数类型可适应函数  
`ptr_fun(function)`

> [!note]  
> 不能在接受引用到`const`参数的函数上使用 `ptr_fun`

如果想要将成员函数转换为可适应函数的情况，可以使用 `mem_fun` 或 `mem_fun_ref` 函数，前者接受接收器对象的指针，后者接受接收器的引用  
eg:

```c++
transform(myVector.begin(), myVector.end(), ostream_iterator<int>(cout, "\n"), mem_fun_ref(&string::length));
```

使用可适配函数的例子：

```c++
bool LengthIsLessThan(string str, int threshold)
{
	return str.length() < threshold;
}

count_if(container.begin(), container.end(), bind2nd(ptr_fun(LengthIsLessThan), 5));
```

`bind1st`和`bind2nd`两个函数接受一个可适应函数和一个要绑定的值作为参数，并返回新的函数，新的函数与旧函数相等，只是将指定的值绑定在相应位置  
上面代码`bind2nd(ptr_fun(LengthIsLessThan), 5)`首先使用 `ptr_fun` 生成一个可适应的版本为 `LengthIsLessThan` 函数，然后使用 `bind2nd` 锁定参数 5。结果是一个新的单参数函数

### 对结果取反

上面的例子是计算小于某一长度的个数，如果想要大于等于的呢？  
`not1`和`not2`分别返回一元和二元参数函数的取反函数

```c++
count_if(container.begin(), container.end(), bind2nd(not2(ptr_fun(LengthIsLessThan)), 5));
```

### 运算符函数

试想我们想要：将 137 加到`vector<int>`每个元素上

```c++
int Add137(int param) {
	return param + 137;
}

transform(container.begin(), container.end(), container.begin(), Add137);

//如果将137变成可调参数：
int AddTwoInts(int one, int two) {
	return one + two;
}

transform(container.begin(), container.end(), container.begin(), bind2nd(ptr_fun(AddTwoInts), 137));
```

但如果需要改为`double`类型的，就需要编写另一个函数避免类型转换问题，这太繁琐了  
因此，STL 提供了模板可适应的函数类，比如`plus<int>`,`plus<int>()(a, b)`  等价于  `a + b`

```c++
transform(container.begin(), container.end(), container.begin(), bind2nd(plus<int>(), 137));
```

> [!note]  
> plus 是类模板，需要加括号实例化，才能用 operator()

由`<functional>`导出的运算符函数：  
`plus` `minus` `multiplies` `divides` `modulus` `negate`
`equal_to` `not_equal_to` `greater` `less` `less_equal` `greater_equal`
`logical_and` `logical_or` `logical_not`

### 统一函数和伪函数(Functors)

如何让你的代码能接受各种“可调用对象”作为参数，包括普通函数、函数指针、仿函数对象、lambda 表达式等  
一个可以接受各种函数参数的模板例子：

```c++
template <typename UnaryFunction> void DoSomething(UnaryFunction fn) {
/* ... */
}
```

如果想用模板设计一个类，可以存储任意类型的函数：

```c++
template <typename WidthFunction>
class Window {
public:
    Window(WidthFunction fn);
private:
    WidthFunction width;
};
```

但缺点很致命：

- **类型复杂**：每种函数类型都要写不同的模板参数，声明很长很难读，尤其是 STL 适配器类型。
- **类型不统一**：不同类型的 Window（如 `Window<int (*)(int)>` 和 `Window<MyFunctorType>`）是完全不同的类型，不能放在同一个  `vector<Window>`  里。
- **接口不统一**：你不能直接写  `void DoSomething(const Window& w)`，因为 Window 是模板，不是具体类型，只能写模板函数，代码变得笨拙。

### 继承

> Theorem (The Fundamental Theorem of Software Engineering): Any problem can be solved by adding enough layers of indirection.
> 任何问题都可以通过添加足够的间接层来解决

定义一个抽象基类（如 IntFunction）

```c++
class IntFunction {
public:
    virtual ~IntFunction() {}
    virtual int execute(int value) const = 0; //纯虚函数
};
```

只定义一个纯虚函数  `execute`，让所有“可调用对象”都能用统一接口调用。
Window 类只保存 IntFunction 指针

```c++
class Window {
public:
    Window(IntFunction* sizeFunction);
private:
    IntFunction* fn;
};
```

这样所有 Window 都是同一个类型，可以统一管理。

**用继承实现不同的行为**
如果你要“窗口宽度不超过 100”，可以写：

```c++
class ClampTo100PixelsFunction : public IntFunction {
public:
    virtual int execute(int size) const { return min(size, 100); }
};
Window myWindow(new ClampTo100PixelsFunction);
```

如果你要“窗口宽度总是 100”，可以写：

```c++
class FixedSizeFunction : public IntFunction {
public:
    virtual int execute(int size) const { return 100; }
};
Window myWindow(new FixedSizeFunction);
```

问题：代码太繁琐

- 每种行为都要写一个新子类，哪怕只是包一行函数指针，也要写一堆类声明。
- 这不够简洁，实际用起来很麻烦。

**优化：用包装类包函数指针或仿函数**  
可以写一个 ActualFunction 类，专门包函数指针：

```c++
class ActualFunction : public IntFunction {
public:
    explicit ActualFunction(int (*fn)(int)) : function(fn) {}
    virtual int execute(int value) const { return function(value); }
private:
    int (*function)(int);
};
Window myWindow(new ActualFunction(ClampTo100Pixels));
```

也可以写一个 MyFunctorFunction 类，专门包仿函数对象：

```c++
class MyFunctorFunction : public IntFunction {
public:
    explicit MyFunctorFunction(MyFunctor fn) : function(fn) {}
    virtual int execute(int value) const { return function(value); }
private:
    MyFunctor function;
};
Window myWindow(new MyFunctorFunction(MyFunctor(137)));
```

上述两种方法实现相同，唯一不同是存储的对象类型不同，可以用模板统一包装函数指针、仿函数

```c++
template <typename UnaryFunction>
class SpecificFunction : public IntFunction {
public:
    explicit SpecificFunction(UnaryFunction fn) : function(fn) {}
    virtual int execute(int value) const {
        return function(value);
    }
private:
    UnaryFunction function;
};

Window myWindow(new SpecificFunction<int(*)(int)>(ClampTo100Pixels));
Window myWindow(new SpecificFunction<MyFunctor>(MyFunctor(137)));
```

这样客户端不再需要实现自己的`IntFunction`子类

### 再抽象一层

目的：把“可调用对象”管理的代码再抽象一层，做成一个通用的 Function 类，方便复用和管理各种函数、仿函数  
**为什么要再抽象一层？**

- 之前 Window 类里直接管理 IntFunction 指针，只能服务于 Window，其他类要用还得重复写一遍。
- 如果把这套机制封装到一个专门的 Function 类里，任何地方都能用，复用性更强。
  实例接口：

```c++
class Function {
public:
    Function(IntFunction* fn);
    ~Function();
    int operator()(int value) const;
private:
    IntFunction* function;
};
```

**支持复制**
`Function`类要能复制，但`IntFuction`是抽象对象，不能直接复制  
解决方法：在 `IntFunction` 里加一个纯虚函数  `clone()`，每个子类实现自己的深拷贝。  
实例：

```c++
class IntFunction {
public:
    virtual ~IntFunction() {}
    virtual int execute(int value) const = 0;
    virtual IntFunction* clone() const = 0;
};

//模板类实现clone
template <typename UnaryFunction>
class SpecificFunction : public IntFunction {
public:
    explicit SpecificFunction(UnaryFunction fn) : function(fn) {}
    virtual int execute(int value) const
    { return function(value); }
    virtual IntFunction* clone() const
    { return new SpecificFunction(*this); }
private:
    UnaryFunction function;
};

//Function的拷贝和析构实现
Function::~Function() { clear(); }
Function::Function(const Function& other) { copyOther(other); }
Function& Function::operator=(const Function& other) {
    if (this != &other) {
        clear();
        copyOther(other);
    }
    return *this;
}
void Function::clear() { delete function; }
void Function::copyOther(const Function& other) {
    function = other.function->clone();
}

//用法举例：
Function myFunction = new SpecificFunction<int(*)(int)>(ClampTo100Pixels);
cout << myFunction(137) << endl; // 输出 100
cout << myFunction(42) << endl;  // 输出 42
```

### 隐藏 SpecificFunction

目前`Function`类具有完整的深度复制支持，使用`SpecificFunction<T>`可以存储任何类型的可调用函数，但`Function`的客户必须显式地包装他们想要调用的任何函数。

- 这打破了封装性
- 要求用户必须知道他们想要在`Function`类中存储的每个函数的类型  
  这个问题可以通过将`Function`构造函数重写为一个模板函数解决  
  将`Function`模板化，不再局限于从`int`到`int`的函数限制  
  代码实现：

```c++
template <typename ArgType, typename ReturnType> class Function {
public:
	/* Constructor and destructor. */
	template <typename UnaryFunction> Function(UnaryFunction);
	~Function();
	/* Copy support. */
	Function(const Function& other);
	Function& operator= (const Function& other);
	/* Function is a functor that calls into the stored resource. */
	ReturnType operator() (ArgType value) const;

private:
	class ArbitraryFunction { /* ... */ };
	template <typename UnaryFunction> class SpecificFunction { /* ... */ }
	ArbitraryFunction* function;

	void clear();
	void copyOther(const Function& other);
};

//构造函数实现：
template <typename UnaryFunction> Function::Function(UnaryFunction fn)
{
	function = new SpecificFunction<UnaryFunction>(fn);
}
```

现在我们可以用新的函数类型重新编写窗口类：

```c++
class Window {
public:
	Window(const Function<int, int>& widthFn, /* ... */
	/* ... other member functions ... */
private:
	Function<int, int> widthFunction;
};
```

### 外部多态

传统多态（internal polymorphism):自己定义一组类，写虚函数，然后用基类指针/引用实现多态  
外部多态（external polymorphism）：用一个包装类（比如`Function`），把任意可调用对象（函数，仿函数，lambda）都包装成同意接口，实现多态调用  
这样，用户只需要用`Fuction`类型，不用关心底层到底是什么类型的函数或仿函数  
代价：  
外部多态比普通虚函数多一层间接（Function 包装 -> 虚函数表 -> 具体函数对象），调用稍慢，但换来了极大的灵活性。

### 实现`<functional>`库

STL 的  `<functional>`  库用类似的技术实现了各种“适配器”和“可适配仿函数”。**adaptable function**：继承自  `unary_function`  或  `binary_function`，自动获得  `argument_type`  和  `result_type`  两个类型别名。  
这些类型别名让 STL 算法和适配器能自动推断参数和返回值类型，方便组合和泛型编程。  
示例：

```c++
template <typename ArgType, typename RetType>
class unary_function {
public:
    typedef ArgType argument_type;
    typedef RetType result_type;
};

class IsPositive : public unary_function<double, bool> {
public:
    bool operator()(double value) const { return value > 0.0; }
};
```

### 实现`not1`

`not1`接受一个一元可适应函数，返回一个新的可适应函数，该函数返回与原始函数相反的值

```c++
template <typename UnaryPredicate>
class unary_negate : public unary_function<typename naryPredicate::argument_type, bool> {  //继承unary_function,让其成为适配器友好仿函数
public:
    explicit unary_negate(const UnaryPredicate& pred) : p(pred) {}
    bool operator()(const typename UnaryPredicate::argument_type& param) const {
        return !p(param);
    }
private:
    UnaryPredicate p;
};
```

我们已经完成编写执行否定操作的仿函数类，接下来编写`not1`，是一个模板函数

```c++
template <typename UnaryPredicate>
unary_negate<UnaryPredicate> not1(const UnaryPredicate& pred) {
    return unary_negate<UnaryPredicate>(pred);
}

```

使用示例：

```c++
//假设有如下谓词
class IsPositive : public std::unary_function<double, bool> {
public:
    bool operator()(double value) const { return value > 0.0; }
};

//查找第一个非正元素：
vector<double>::iterator itr = find_if(v.begin(), v.end(), not1(IsPositive()));
//如果不用not1,则必须写：
vector<double>::iterator itr = find_if(v.begin(), v.end(), unary_negate<IsPositive>(IsPositive()));
```

### 实现`ptr_fun`

`ptr_fun`和`not1`以相同的方式工作——各自接受一个参数，构造一个特殊的函数类并返回
`ptr_fun`不同的是有两个版本  
一元函数：

```c++
template <typename ArgType, typename RetType>
class pointer_to_unary_function : public std::unary_function<ArgType, RetType>
{
public:
    explicit pointer_to_unary_function(RetType (*fn)(ArgType)) : function(fn) {};
    RetType operator()(const ArgType &param) const
    {
        return (*function)(ArgType);
    }

private:
    RetType (*function)(ArgType);
};

template <typename ArgType, typename RetType>
pointer_to_unary_function<ArgType, RetType>
ptr_fun(RetType (*function)(ArgType)) //传入函数指针，返回包装后的仿函数对象
{
    return pointer_to_unary_function<ArgType, RetType>(function);
}
```

二元函数：

```c++
template <typename Arg1, typename Arg2, typename Ret>
class pointer_to_binary_function : public std::binary_function<Arg1, Arg2, Ret> {
public:
    explicit pointer_to_binary_function(Ret (*fn)(Arg1, Arg2)) : function(fn) {}
    Ret operator()(const Arg1& arg1, const Arg2& arg2) const {
        return function(arg1, arg2);
    }
private:
    Ret (*function)(Arg1, Arg2);
};


template <typename Arg1, typename Arg2, typename Ret>
pointer_to_binary_function<Arg1, Arg2, Ret>
ptr_fun(Ret (*function)(Arg1, Arg2)) {
    return pointer_to_binary_function<Arg1, Arg2, Ret>(function);
}
```

### 实现`bind1st`

接受一个二元可适应函数和一个值，然后返回一个新的单参数函数  
`binary_function`提供：  
`first_argument_type`第一个参数的类型，`second_argument_type`第二个参数的类型，`result_type`返回类型

```c++
template <typename BinaryFunction>
class binder1st : public std::unary_function<typename BinaryFunction::second_argument_type,
typename BinaryFunction::result_type>
{
public:
    binder1st(const BinaryFunction &fn, const typename BinaryFunction::first_argument_type &arg)
    : function(fn), first(arg) {}
    typename BinaryFunction::result_type
    operator()(const typename BinaryFunction::second_argument_type &param) const
    {
        return function(first, param);
    }

private:
    BinaryFunction function;
    typename BinaryFunction::first_argument_type first;
};

template <typename BinaryFunction>
binder1st<BinaryFunction> //返回类型
bind1st(const BinaryFunction& fn, const typename  BinaryFunction::first_argument_type& arg) {
	return binder1st<BinaryFunction>(fn, arg);
}
```

### `functional`库的局限性

只提供了对一元函数和二元函数的支持

## More to Explore

### C++0x

C++0x 是 C++11 的旧称

### 类型推断

用`auto`关键字可以自动推断类型

```c++ {12}
void DoSomething(const multimap<string, vector<int>> &myMap)
{
    const pair<multimap<string, vector<int>>::const_iterator,
               multimap<string, vector<int>>::const_iterator>
        eq = myMap.equal_range("String!");
    for (multimap<string, vector<int>>::const_iterator itr = eq.first; itr != eq.second; ++itr)
        cout << itr->second.size() << endl;
}

void DoSomething(const multimap<string, vector<int>> &myMap)
{
    const auto eq = myMap.equal_range("String!");
    for (auto itr = eq.first; itr != eq.second; ++itr)
        cout << itr->second.size() << endl;
}
```

`decltype(expr)`  用于获取表达式的类型，但不实际计算表达式，只返回类型信息。常用于模板编程和复杂函数声明。

```c++
decltype(1 + 2) x; // x 的类型是 int
decltype(new char) p; // p 的类型是 char*
```

### 移动语义

问题：拷贝低效性（需要创建完整副本，然后释放原始内存）  
解决：不拷贝数据而是转移数据的所有权

C++11 引入了一种新的变量类型——==右值引用== `type &&`

```c++
//移动构造函数
template <typename T>
vector<T>::vector(vector&& other) {
    elems = other.elems;        // 接管资源
    len = other.len;

    other.elems = nullptr;      // 清空原对象
    other.len = 0;
}

//移动赋值运算符
template <typename T>
vector<T>& vector<T>::operator=(vector&& other) {
    if(this != &other) {
        delete[] elems;         // 清理当前资源

        elems = other.elems;    // 接管新资源
        len = other.len;

        other.elems = nullptr;  // 清空原对象
        other.len = 0;
    }
    return *this;
}
```

`move`函数：`<utility>`头文件导出的特殊辅助函数  
将对象转换为右值引用，明确表示这个对象可以的被移动

```c++
vector<int> a = {1, 2, 3};
vector<int> b = std::move(a); // 移动 a 到 b，a 变为空
```

只能移动不适合拷贝的对象：  
`ofstream`

```c++
ofstream GetTempFile() {
    ofstream result("temp.txt");
    return result; // 使用移动构造函数，不是拷贝构造函数
}
```

C++11 引入了`unique_ptr`(代替了`auto_ptr`)像 `auto_ptr` 一样，代表一个智能指针，当它超出作用域时自动清理其底层资源。然而，与 `auto_ptr` 不同，`unique_ptr` 不能被复制或赋值，但可以自由移动

```c++
std::unique_ptr<int> ptr1(new int(42));
std::unique_ptr<int> ptr2 = ptr1;           // 错误！不能拷贝
std::unique_ptr<int> ptr3 = std::move(ptr1); // 正确！可以移动
```

### lambda 表达式

基本语法：

```c++
[capture](parameters) -> return_type { body }
```

捕获列表：

- 按值捕获`[=]`,直接拷贝
- 按引用捕获`[&]`,引用值
- 混合捕获

```c++
int factor = 10;
int sum = 0;
auto lambda = [factor, &sum](int x) {
    sum += x * factor; // factor 按值，sum 按引用
};
```

- 指定捕获

```c++
int a = 1, b = 2, c = 3;
auto lambda = [a, &b](int x) { return a + b + x; }; // 只捕获 a 和 b
```

### 可变参数模板

允许模板接受任意数量的参数，解决了传统 C++ 中需要为不同参数个数写多个模板类的问题  
问题：  
传统 C++ 中，如果要支持不同参数个数的函数，需要分别定义：

```c++
// 一元函数包装器
template <typename ArgType, typename ReturnType>
class Function { /* ... */ };

// 二元函数包装器
template <typename ArgType1, typename ArgType2, typename ReturnType>
class BinaryFunction { /* ... */ };

// 三元函数包装器
template <typename ArgType1, typename ArgType2, typename ArgType3, typename ReturnType>
class TernaryFunction { /* ... */ };
```

- 代码重复，结构几乎相同
- 需要预先确定支持的最大参数个数
- 维护困难，扩展性差

基本语法：

```c++
template <typename... Args> class Tuple {
    // Args 是参数包（parameter pack），代表任意数量的类型
    // 不能直接使用 `Args`，必须通过模式表达式展开
};
```

展开：

```c++
template <typename... Args> class Tuple {
public:
    Tuple(const Args&...);  // 展开为多个 const 引用参数
};

// 实例化示例：
Tuple<int> t1;                    // Tuple(const int&)
Tuple<int, double> t2;            // Tuple(const int&, const double&)
Tuple<int, double, string> t3;    // Tuple(const int&, const double&, const string&)
```

## Object-Oriented Programming

## 继承

### 实现和接口的继承

派生类可以继承基类的所有公有成员函数，在此基础上实现新的功能

```c++
class BatchPrinter : public Printer // 从 Printer 继承
{
public:
    void enqueueDocument(const string& document);
    void printAllDocuments();
private:
    queue<string> documents; // 文档队列
};
```

> [!tip]  
> 期望基类的地方可以传入派生类
> 因为派生类拥有基类的所有功能，这是安全的

### 接口继承

标注`virtual`虚函数关键字的函数

```c++
class emp
{
public:
	virtual void demo();
};

class emp_derived: public emp
{
public:
	void demo();
};

emp *e1 = new emp();
e1->demo();
emp *e2 = new emp_derived();
e2->demo();
```

这样实体调用实际类型的函数而非指针类型的函数  
应该显式地标注想要多态处理的成员函数（virtual）

`protected`修饰符  
`protected`标记的数据成员可以被派生类访问

基类的析构函数应该被标记为虚拟析构函数，这样 C++会先调用派生类析构函数，再调用基类析构函数

```c++
BaseClass *myClass = new DerivedClass;
delete myClass;
```

### 调用其他版本的函数

```c++
void HybridCar::applyBrakes()
{
	Car::applyBrakes(); //调用基类的函数版本
	chargeBattery();
};
```

默认情况下，派生类的构造函数会调用其基类的默认构造函数，如果想要调用基类自定义构造函数：

```c++
class Car
{
public:
	explicit Car(const string& licenseNum) : license(licenseNum) {}
	virtual ~Car() {}
private:
	const string license;
};

class HybridCar: public Car
{
public:
	explicit HybridCar(const string& license) : Car(license) {}
private:
};
```

> [!note]  
> 只能指定直接基类的名称，不能调用间接基类的构造函数

在构造函数和析构函数中，虚函数不会发生多态调用，而是调用当前正在构造/析构的类的版本

```c++
class base
{
public:
    base()
    {
        fn();
    }
    virtual void fn()
    {
        cout << "base" << endl;
    }
};

class derived: base
{
    virtual void fn()
    {
        cout << "derived" << endl;
    }
};

int main()
{
    derived *demo = new derived(); //会输出base
}
```

### 派生类复制构造函数与赋值运算符

当派生类想复制一个对象时，可能出现两种问题：  
只复制了派生类数据，没有基类数据  
解决：加上基类的复制函数

```c++
class Derived : public Base {
private:
    string derivedData;

public:
    Derived(int base = 0, string derived = "")
        : Base(base), derivedData(derived) {}

    // ✅ 正确的拷贝构造函数
    Derived(const Derived& other): Base(other),  // 关键：调用基类拷贝构造函数
          derivedData(other.derivedData)
    {
        cout << "Derived copy constructor" << endl;
    }

    // ❌ 错误的写法（不调用基类拷贝构造函数）
    // Derived(const Derived& other)
    //     : derivedData(other.derivedData) {  // 基类部分未正确拷贝
    // }
};
```

另一种情况是只复制了基类数据，而没有复制派生类函数，称为对象切片**slicing**  
常见于，将派生对象赋给基类(永远不该这么做)：

```c++
void DoSomething(Base baseObject)
{
// Do something
}
Derived myDerived
DoSomething(myDerived);
```

### 类型转换运算符

传统 C 风格转换的问题  
过于危险的转换

```c++
Base* myBasePtr = new Derived();

// C 风格转换太强大，什么都能转
vector<double>* myVectorPtr = (vector<double>*)myBasePtr; // 完全错误但能编译

//去掉了 const 限制
const Base* constPtr = myBasePtr;
Derived* myDerivedPtr = (Derived*)constPtr;
```

C++提供了四个称为转换运算符的特殊运算符，可以使用它们来执行更安全的类型转换
**static_cast**会在编译时检查转换“是否有意义”,可以执行以下转换：

1. 在原始类型之间进行转换（例如，int 转换为 float 或 char 转换为 double）
2. 在派生类型的指针或引用与基类型的指针或引用之间进行转换（例如，`Derived *` 到 `Base *`），其中`const`一致。
3. 在基类型指针或引用与派生类型指针或引用之间进行转换（例如，从 `Base *`转换为 `Derived *`），其中`const`一致。

**dynamic_cast**，它在执行转换之前会进行额外的检查，如果请求的类型转换在运
行时无效（例如，尝试将 `Base` 对象转换为 `Derived` 对象），`dynamic_cast` 将返回一个 NULL 指针  
两点注意：  
只有当基类类型至少包含一个虚成员函数时，才能使用  
在引用之间进行转换而不是指针时，当转换失败时，`dynamic_cast` 将抛出一个类型为 `bad_cast` 的对象

**The End**

> 2025.10.7
